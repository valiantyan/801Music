---
description: 敏捷开发工作流、文档状态管理与大厂级工程规范
globs: 
alwaysApply: true
---
# 敏捷工作流与核心记忆程序规则 (Expert Edition) - 必须严格遵守！

**关键规则**：本项目采用 **"文档即代码 (Docs-as-Code)"** 与 **"业界大厂工程标准"** 相结合的开发模式。
所有的记忆锚点位于 `.ai/` 目录。你必须维护文档与代码的严格一致性，并遵守 **YAGNI (You Ain't Gonna Need It)** 原则，杜绝过度设计与范围蔓延。

---

## 核心阶段与文档依赖链

**状态流转原则**：仅当上游文档 YAML `status: 已批准` 时，下游工作方可启动。
**异常处理**：遇到 `Bug` 或 `Spike` (探针/调研) 任务时，适用特定的快速通道规则（见下文）。

1.  **初始化与 PRD 基础构建**：
    *   检查 `.ai/prd/index.md` 和 `.ai/prd/APP-Overall-Vision.md`。
    *   若不存在，使用 `.ai/templates/` 下对应模板创建。
    *   **目标**：确立项目愿景与范围。

2.  **Feature (特性) 定义**：
    *   使用 `.ai/templates/template-prd-feature.md` 创建 `.ai/prd/features/[feature-name]/index.md`。
    *   **目标**：明确功能范围、用户故事列表。需用户批准。

3.  **架构设计 (Architecture)**：
    *   创建/更新 `.ai/architecture/arch-overview.md`。
    *   **架构前瞻性**：在此阶段需进行"面向未来的设计 (Design for Future)"，定义好扩展接口，但**不要**在编码阶段提前实现这些接口的逻辑。

4.  **Story (故事) 创建与分类**：
    *   在 Feature 的 `stories/` 目录下创建 Story。
    *   **根据任务类型选择策略**：

    | Story 类型 | 命名规范 | 审批流程 | 产出物 |
    | :--- | :--- | :--- | :--- |
    | **Feature** (标准) | `[ID]-[描述].md` | 需 PRD/Arch 已批准 | 生产代码 + 测试 |
    | **Bug** (修复) | `BUG-[ID]-[描述].md` | **快速通道**：跳过 Feature 审批，直接进入修复 | 修复代码 + 回归测试 + **文档同步** |
    | **Spike** (探针) | `SPIKE-[ID]-[描述].md` | 需定义 **Timebox** (时间/轮次限制) | **知识/文档** (代码不进生产环境) |

---

## 🛑 开发执行铁律 (The Red Lines) - 业界大厂标准

在执行 Story 开发（尤其是 Feature 类型）时，必须遵守以下铁律。**违规者将被视为工程纪律失败。**

### 1. 严格的 YAGNI 与边界控制 (Strict Scope Control)
*   **禁止预测性编程**：**只实现**通过当前 Story 测试用例所需的**最少代码**。
*   **禁止偷跑**：即使你知道 Story 3 需要某个功能，只要当前 Story (Story 1) 的验收标准 (AC) 没提到，就**绝对不要写**。
*   **边界桩机制 (Stubbing)**：如果当前 Story 依赖一个属于未来 Story 的模块：
    *   **禁止实现**：严禁去写那个模块的业务逻辑。
    *   **必须 Mock**：定义一个空接口或 Stub，返回假数据以跑通当前测试。
    *   **标记**：在桩代码上注释 `TODO: To be implemented in Story [ID]`。

### 2. 分层测试策略 (Pragmatic Testing)
*   **纯逻辑/数据层**：严格执行 **TDD (红-绿-重构)**。先写失败的单元测试，再编码。
*   **UI/视图层**：执行 **预览驱动开发 (Preview-Driven Development)**。
    1.  创建 UI 组件预览 (Preview/Storybook)。
    2.  确认视觉效果符合预期。
    3.  **结项要求**：在 Story 完成前，必须将关键预览固化为 **截图测试 (Snapshot Test)** 或 **组件测试**，作为回归防线。

### 3. 重构的边界
*   重构仅限于**改进现有代码结构**。
*   如果在重构中发现需要"增加新功能"才能支持后续 Story，**立即停止**。这是下一个 Story 的工作，不是现在的。

---

## Story 生命周期管理

### A. 启动前检查 (Pre-flight Check)
在将 Story 状态转为 `进行中` 之前：
1.  扫描现有代码库。
2.  检查 Story 中的任务是否已被之前的 Story 意外完成（尽管我们尽力避免，但如发生，需识别）。
3.  如有重叠，**不要重复编码**，转为补充测试用例。

### B. 开发中 (In Progress)
*   持续更新 Story `.md` 文件中的 `Task List` 和 `Development Log`。
*   遇到架构冲突：
    *   **小调整**（类名、参数）：直接更新架构文档。
*   **大变更**（数据流、模块依赖）：**暂停 Story**，请求用户介入或创建架构重构任务。

### Bug 记录格式 (Mandatory)
在 Story 的 `Development Notes & Log` 中记录 Bug 时，必须使用以下固定格式（逐行换行）：

Bug 描述：...
问题原因：...
解决方案：...
影响范围：...

### C. 完成标准 (Definition of Done - DoD)
一个 Story 只有满足以下所有条件才算 `已完成`：

1.  **代码层面**：所有子任务完成，单元测试/UI测试通过，无 Lint 错误。
2.  **一致性自检 (Sanity Check)**：
    *   AI 必须反思："本 Story 的最终实现是否改变了系统架构或业务逻辑？"
    *   如果是（特别是 Bug 修复类），必须**反向更新** PRD 或 架构文档。
3.  **清理**：删除临时代码，确保无被注释掉的废弃代码。

## 您不需要征求许可即可：

1.  根据上述规则创建下一个 Story 的草稿（Feature/Bug/Spike）。
2.  运行测试直到通过。
3.  更新 Story 文档的进度和日志。
4.  在发现代码与文档微小不一致时，**自动修正文档**以保持同步。

**切记：设计面向未来，编码活在当下。严守边界，文档即真理。**
